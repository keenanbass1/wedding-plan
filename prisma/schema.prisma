// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(cuid())
  authId    String    @unique  // Supabase auth.users.id
  email     String    @unique
  name      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  weddings Wedding[]
}

model Wedding {
  id                String        @id @default(cuid())
  userId            String
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Wedding Details
  weddingDate       DateTime?
  dateFlexible      Boolean       @default(false)
  location          String?       // "Sydney, NSW" or specific suburb
  guestCount        Int?
  budgetTotal       Int?          // In cents (AUD)
  budgetVenue       Int?
  budgetCatering    Int?
  budgetPhotography Int?

  // Preferences
  style             String?       // "modern", "rustic", "formal", "casual"
  mustHaves         String[]      // Array of requirements
  dealBreakers      String[]
  dietaryNeeds      String[]
  accessibilityReqs String?

  // Status
  status            WeddingStatus @default(INTAKE)
  chatCompleted     Boolean       @default(false)

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  conversations  Conversation[]
  vendorOutreach VendorOutreach[]
  savedVendors   SavedVendor[]
}

enum WeddingStatus {
  INTAKE    // Gathering information via AI chat
  MATCHING  // Finding vendors
  OUTREACH  // Emails sent
  REVIEWING // User reviewing responses
  COMPLETED // User made decisions
}

model Conversation {
  id        String   @id @default(cuid())
  weddingId String
  wedding   Wedding  @relation(fields: [weddingId], references: [id], onDelete: Cascade)

  messages Json // Array of {role: 'user'|'assistant', content: string, timestamp: DateTime}

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Vendor {
  id String @id @default(cuid())

  // Basic Info
  name        String // Display name
  businessName String? // Legal business name (optional)
  category     VendorCategory
  email        String // Primary contact
  phone        String?
  website      String?

  // Location
  location  String // Main city/area (e.g., "Newcastle")
  region    String? // Broader region (e.g., "Hunter Valley")
  suburb    String? // Specific suburb
  state     String  @default("NSW")
  address   String?
  latitude  Float?
  longitude Float?

  // Pricing
  priceMin         Int? // Minimum price
  priceMax         Int? // Maximum price
  priceDescription String? // Text description of pricing
  priceRange       PriceRange?

  // Capacity & Services
  capacity        VendorCapacity? // Size category
  maxGuests       Int? // Max guests (for venues)
  servicesOffered String[] // ["Ceremony venue", "Reception venue", etc.]

  // Style & Attributes
  styles      String[] // ["Rustic", "Modern", "Luxury", etc.]
  description String   @db.Text

  // Quality Metrics
  rating        Float? // Average rating (0-5)
  verified      Boolean   @default(false)
  responseRate  Float? // 0.0 - 1.0 (calculated from outreach history)
  lastContacted DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  outreach VendorOutreach[]
  savedBy  SavedVendor[]

  @@index([category, location])
  @@index([category, suburb])
}

enum VendorCapacity {
  SMALL  // < 50 guests
  MEDIUM // 50-150 guests
  LARGE  // 150+ guests
}

enum VendorCategory {
  VENUE
  PHOTOGRAPHER
  CATERING
  FLORIST
  ENTERTAINMENT
  MARQUEE
  OTHER
}

enum PriceRange {
  BUDGET   // $
  MODERATE // $$
  PREMIUM  // $$$
  LUXURY   // $$$$
}

model VendorOutreach {
  id        String  @id @default(cuid())
  weddingId String
  wedding   Wedding @relation(fields: [weddingId], references: [id], onDelete: Cascade)
  vendorId  String
  vendor    Vendor  @relation(fields: [vendorId], references: [id])

  // Email Details
  emailSubject String
  emailBody    String        @db.Text
  emailId      String?       // Resend email ID for tracking
  sentAt       DateTime?

  // Tracking
  delivered   Boolean   @default(false)
  deliveredAt DateTime?
  opened      Boolean   @default(false)
  openedAt    DateTime?
  replied     Boolean   @default(false)
  repliedAt   DateTime?
  bounced     Boolean   @default(false)

  // Response
  responseEmail String?            @db.Text // Raw email response (if replied)
  availability  VendorAvailability?
  quote         Int? // In cents
  notes         String?            @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([weddingId, vendorId])
}

enum VendorAvailability {
  AVAILABLE
  UNAVAILABLE
  TENTATIVE
  UNKNOWN
}

model SavedVendor {
  id         String  @id @default(cuid())
  weddingId  String
  wedding    Wedding @relation(fields: [weddingId], references: [id], onDelete: Cascade)
  vendorId   String
  vendor     Vendor  @relation(fields: [vendorId], references: [id])

  notes      String?
  isFavorite Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([weddingId, vendorId])
}

